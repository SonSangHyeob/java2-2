# 손상협 202330214

## 5월 3일
컬렉션의 개념
    컬렉션
        요소라고 불리는 가변 개수의 객체들의 저장소
            객체들의 컨테이너라고도 불림
            요소의 개수에 따라 크기 자동 조절
            요소의 삽입, 삭제에 따른 요소의 위치 자동 이동
        고정 크기의 배열을 다루는 어려움 해소
        다양한 객체들의 삽입, 삭제, 검색 등의 관리 용이
컬렉션의 특징
    컬렉션은 제네릭 기법으로 구현
        제네릭
            특정 타입만 다루지 않고, 여러 종류의 타입으로 변신할 수 있도록 클래스나 메소드를 일반화시키는 기법
            클래스나 인터페이스 이름에 E K V 등 타입매개변수 포함
        제네릭컬렉션 사례 : 벡터Vector<E>
            E 에서 E에 구체적인 타입을 주어 구체적인 타입만 다루는 벡터로 활용
            정수만 다루는 컬렉션 벡터Vector<Integer>
            문자열만ㅁ 다루는 컬렉션 벡터Vector<String>
    컬렉션의 요소는 객체만  가능
        int char double 등의 기본 타입으로 구체화 불가
제네릭의 기본 개념
    제네릭
        JDK 1.5부터 도입
        모든 종류의  데이터 타입을 다룰 수 있도록 일반화된 타입 매개 변수로 클래스나 메소드를 작성하는 기번
        C++의 템플릿과 동일
Vector<E>
    벡터<E>의 특성
        E에 사용할 요소의 특정 타입으로 구체화
        배열을 가변 크기로 다룰 수 있게 하는 컨테이너
            배열의 길이 제한 극복
            요소의 개수가 넘ㅊ면 자동으로 길이 조절
        요소 객체들을 삽입, 삭제, 검색하는 켄테이너
            삽입, 삭제에 따라 자동으로 요소의 위치 조정
        Vector에 삽입 가능한 것
            객체, null
            기본 타입의 값은 Wrapper 객체로 만들어 저장
        Vector에 객체 삽입
            벡처의 맨 뒤, 중간에 객체 삽입 가능
        Vector에서 객체 삭제
            임의의 위치에 있는 객체 삭제 가능
컬렉션 생성문의  진화 : JAVA 7, JAVA 10
    JAVA 7 이후
        컴파일러의 타입 추론 기능 추가
        <>다이어몬드 연산자에 타입 매개변수 생략
ArrauList<E>
    가변 크기 배열을 구현한 클래스
    벡터와 거의 동일
컬렉션의 순차 검색을 위한 iterator
     iterator<E> 인터페이스
        리스트 구조의 컬렉션에서 요소의 순차 검색을 위한 인터페이스
            Vector<E> ArrayList<E> LinkedList<E>가 받는 상속받는 인터페이스
    iterator 객체 얻어내기
HashMap<K,V>
    키와 갑의 쌍으로 구성되는  요소를 다루는 컬렉션
        K 키로 사용할  요소의 타입
        V 값으로 사용할 요소의 타입
        키와 값이  한 쌍으로 삽입
        값을 검색하기 위해서는 반드시 키 이용
    삽입 및 검색이 빠른 특징
        요소 삽입 : put 메소드
        요소 검색 : get 메소드
제네릭 만들기
    제네릭 클래스 작성
        클래스 이름 옆에 일반화된 타입 매개 변수 추가
    제네릭 객체 생성 및 활용
        제네릭 타입에 구체적인 타입을 지정하여 객체를 생성하는 것을 구체화라고 함
자바의 GUI
    GUI 응용프로그램
        GUI
            사용자가 편리하게 입출력 할 수 있도록 그래픽으로 화면을 구성하고, 마우스나 키보드로 입력 받을 수 있도록 지원하는 사용자 인터페이스
        자바 언어에서 GUI 응용프로그램 작성
            AWT와 Swing패키지
스윙 프레임
    스윙 프레임 : 모든 스윙 컴포넌트를 담는 최상위 컨테이너
    JFrame 클래스를 상속받은 클래스 작성
    프레임의 크기 반드시 지정 : setSize() 호출
    프레임을 화면에 출력하는 코드 반드시 필요 : setVisible(true) 호출
프레임에 컴포넌트 붙이기
    타이틀 달기
        super() 나 setTitle()이용
    컴텐트팬에 컴포넌트 달기

## 4월 19일
super
    슈퍼 클래스의 멤버를 접근할 때 사용되는 레퍼런스
추상 클래스는 온전한 클래스가 아니기 때문에 인스턴스를 생성할 수 없음
패키지
    서로 간련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉터리
    하나의 으용프로그램은 한 개 이상의 패키지로 작성
    패키지는 jar 파일로 압축할 수 있음
모듈
    여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너
    하나의 모듈을 하나의 jmod 퍼일에 저장
JAVA 9부터 모듈화 도입
모듈화의 목적
    Java 9부터 자바 API를 여러 모듈(99개)로 분할
        Java 8까지는 rt.jar의 한 파일에 모든 API저장
    웅용프로그램이 실행할 때 꼭 필요한 모듈둘로만 실행 환경 구축
        메모리 자원이 열약한 작은 소형 기기에 꼭 필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함
모듈의 현실
    Java 9부터 전면적으로 도입
    복잡한 개념
    큰 자바 응용프로그램에는 개발, 유지보수 등에 적합
    현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요 없음
패키지 만들기
    클래스 파일이 저장되는 위치
        클래스나 인터페이스가 컴파일되면 클래스 파일 생성
        클래스 파일은 패키지로 선언된 디렉터리에 저장
    패키지 선언
        소스 파일의 맨 앞에 컴파일 후 저장될 패키지 지정
toString() 메소드, 객체를 문자열로 변환
    각 클래스는 toString()을 오버라이딩하여 자신만의 문자열 작성
객체 비교(==)와 equals()메소드
    ==연산자
        객체 레퍼런스 비교
    boolean equals(Object obj)
        두 객체의 내용물 비교
Wrapper 클래스
        자바의 기본 타입을 클래스화한 8개 클래스를 통칭
    용도
        객체만 사용할 수 있는 컬렉션 등에 기본 타입의 값을 사용하기 위해 --> Wrapper 객체로 만들어 사용
박싱과 언박싱
    박싱
        기본 타입의 값을 Wrapper 갹채로 변환 하는것
스트링 리처럴과 new String()
    스트링 리터럴
        자바 가상 기계 내부에서 리터럴 테이블에 저장되고 관리됨
        으용프로그램에서 공유됨
    

## 4월 12일
접근 지정자
    자바의 접근 지정자
        4가지
            private, protected, public, 디폴트
    자바 지정자 목적
        클래스나 이부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
        객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
            접근 지정은 캡슐화에 묶인 보호를 이부 해제할 목적
    접근 지정자에 따른 클래스나 멤버의 공개 법위
클래스 접근 지정
    클래스 접근지정
        가른 클래스에서 사용하도록 허용할 지 지정
        public 클래스
            다른 모든 클래스에게 접근 허용
        디폴트 클래스
            package-private라고도 함
            같은 패키지의 클래스에만 접근 허용
멤버 접근 지정
    public 멤버
        패키지에 관계 없이 모든 클래스에게 접근 허용
    private 멤버
        동일 클래스 내에만 접근 허용
        상속 받은 서브 클래스에서 접근 불가
    protected 멤버
        같은 패키지 내의 다른 모든 클래스에게 접근 허용
        상속 받은 서브 클래스는 다른 패키지에 있어도 접근 가능
static 멤버 선언
    static 멤버 선언
    객체 생성과 non-static 멤버의 생성
        non-static 멤버는 객체가 생성될 때, 객체마다 생긴다
static 멤버의 생성
    static 멤버는 클래스당 하나만 생성
    객체들에 의해 공유됨
static 멤버 사용
    클래스 이름으로 접근 가능
    객체의 멤버로 접근 가능
    non-static 멤버는 클래스 이름으로 접근 안 됨
final 필드
    final 필드, 상수 선언
        상수를 선언할 때 사용
        상수 필드는 선언 시에 초기 값을 지정하여야 한다
        상수 필드는 실행 중에 값을 변경할 수 없다
자바 상속의 특징
    클래스 다중 상속 불허
        C++는 다중 상속 가능
슈퍼 클래스의 대한 서브 클래스의 접근
    슈퍼 클래스의 private 멤버
        서브 클래스에서 접근할 수 없음
    슈퍼 클래스의 디폴트 멤버
        서브 클래스가 동일한 패키지에 있을 때, 접근 가능
다운캐스팅
    다운캐스팅
        슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
        업캐스팅된 것을 다시 원래대로 되돌리는 것
        반드시 명시적 타입 변환 지정
업캐스팅 레퍼런스로 객체 구별
    업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
        슈퍼 클래스는 여러 서브 클래스에 상속되기 때문
instanceof 연산자 사용
    instanceof연산자
        instanceof연산자
            레퍼런스가 가리키는 객체의 타입 식별


## 4월 5일
메소드의 배열 리턴
    배열 리턴
        배열의 레퍼런스만 리턴
    메소드의 리턴 타입
        리턴하는 배열 타입과 리턴 받는 배열 타입 일치
        리턴 타입에 배열의 크기를  지정하지 않음
자바의 예외 처리
    예외 처리
        발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것
        try catch finally문 사용
자바의 객체 지향 특성 : 캡슐화
    캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게  하는 것
        객체의 가장 본질적인 특징
            외부의 접근으로부터 객체 보호
자바의 객체 지향 특성 : 상속
    상위 개체의 속성이 하위 개체에 물려짐
    하위 개체가 상위 개체의 속성을 모두 가지는 관계
자바 상속
    상위 클래스의 멘버를 하위 클래스가 물려받음
        상위 클래스 : 수퍼 클래스
        하위 클래스 : 서브 클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 가능
자바의 객체 지향 특성 : 다형성
    같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
    다향성 사례
        메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
        메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현
객체 지향 언어의 목적
    소프트웨어의 생산성 향상
        컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축
            소프트웨어를 빠른 속도로 생산할 필요성 증대
        객체 지향 언어
            상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
            소프트웨어 재사용과 부분 수정 빠름
            소프트웨어를 다시 만드는 부담 대폭 줄임
            소프트웨어 생산성 향상
    실세계에 대한 쉬운 모델링
        초기 프로그래밍
            수학 계산/통계 처리를 하는 등 처리 과정, 계산 절차 중요
절차 지향 프로그래밍과 객체 지향 프로그래밍
    절차 지향 프로그래밍
        작업 순서를 표현하는 컴퓨터 명령 집합
        함수들의 집합으로 프로그램 작성
클래스와 객체
    클래스
        객체의 속성가 행위 선언
        객체의 설계도 혹은 틀
    객체
        클래스의 틀로 찍어낸 실체
            프로그램 실행 중에 생성되는 실체
            메모리 공간을 갖는 구체적인 실체
            인스턴스 라고도 부름
자바 클래스 구성
    클래스
        class 키워드로 선언
        멤버 클래스 구성 요소
            필드와 메소드
        클래스에 대한 publilc 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락
        멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용
생성자 개념과 목적
    생성자
        객체가 생성될 떄 초기화 목적으로 실행되는 메소드
        객체가 생성되는 순간에 자동 호출
생성자의 특징
    생성자 이름은 클래스 이름과 ㅜ동일
    생성자는 여러 개 작성 가능
    생성자는 객체 생성시 한 번만 호출
        자바에서 객체 생성은 반드시 new 연산로 함
기본 생성자가 자동 생성되지 않는 경우
    클래스에 생성자가 선언되어 있는 경우
        컴파일러는 기본 생성자를 자동 생성해 주지 않는다.
this 레퍼런스
    this
        객체 자신에 대한 레퍼런스
            컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
            this멤버 형태로 멤버를 접근할 떄 사용
객체 배열
    자바의 객체 배열
        객체에 대한 레퍼런스 배열임
    자바의 객체 배열 만들기 3단계
        1.배열 레퍼런스 변수 선언
        2.레퍼런스 배열 생성
        3.배열의 각 원소 객체 생성
메소드
    메소드는 c/c+와 함수와 동일
인자 전달 - 객체가 전달되는 경우
    객체의 레퍼런스만 전달
        매개 변수가 실인자 객체 공유
인자 전달 - 배열이 전달되는 경우
    배열 레퍼런스만 매개 변수에 전달
        배열 통째로 전달되지 않음
    객체가 전달되는 경우와 동일
        매개 변수가 실인자 배열 공유
메소드 오버로딩
    오버로딩
        한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
            메소드 이름이 동일하여야 함
            매개 변수의 개수가 서로 다르거나, 타입이 서로 달라야 함
            리턴 타입은 오버로딩과 관련이 없음
객체 소멸

        new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위
        소멸된 객체 공간은 가용 메모리에 포함
    자바에서 사용자 임의로 객체 소멸안됨
        자바는 객체 소멸 연산자 없음
            객체 생성 연산자 : new
        객체 소멸은 자바 가상 기계의 고유한 역할
        자바 개발자에게는 매우 다행스러운 기능
가비지
    가비지
        가리키는 레퍼런스가 하나도 없는 객체
가비지 컬렉션
    가비지 컬렉션
        자바 가상 기계가 가비지 자동 회수
            가용 메모리 공간이 일정 이하로 부족해질 떄
            가비지를 수거하여 가용 메모리 공간으로 확보
        가비지 컬렉터에 의해 자동 수행
    강제 가비지 컬렉션 강제 수행
자바의 패키지 개념
    패키지
        상호 관련 있는 클래스 파일을 저장하여 관리하는 디렉터리
        자바 응용프로그램은 하나 이상의 패키지로 구성

    

## 3월 29일
기본 타입 이외 리터럴
    null 리터널
        레퍼런스에 대입 사용
상수 선언
    final키워드 사용
    선언 시 초깃값 지정
    실행 중 값 변경 불가
var 키워드
    기존의 변수 선언 방식 : 변수의 타입 반드시 지정
    타입을 생략하고 변수 선언 가능
    컴파일러가 추론하여 변수 타입 결정
    변수 선언 시 초깃갑이 주어지지 않으면 컴파일 오류
    var는 지역 변수 선언에만 한정
타입 변환
    한 타입의 값을 다른 타입의 값으로 변환
강제 타입 변환
    개발자의 의도적 타입 변환
    () 안에 개발자가 명시적으로 타입 변환 지정
    강제 변환은 값 손실 우려
자바의 키 입력과 system.in
    키보드와 연결된 자바의 표준 입력 스트림
    입력되는 키를 바이트로 리턴하는 저수준 스트림
    system.in을 직접 사용하면 바이트를 문자나 숫자로 변환
scanner 클래스
    읽은 바이트를 문자, 정수, 실수, 불린, 문자열 등 다양한 타입으로 변환하여 리턴
    객체 생성
scanner를 이용한 키 입력
    scanner에서 키 입력 받기
    개발자가 원하는 타입 값으로 쉽게 읽을 수 있음
증감 연산
    증가 혹은 감소 시키는 연산
비교 연산, 논리 연산
    비교연산자 : 두 개의 값을 비교하여 true/false 결과
    논리연산자 : 두 개의 값에 논리 연산, 논리 결과
조건 연산
    3 개의 피연산자로 구성된 삼향 연산자


## 3월 22일
ctrl shift p java p create java

소스:프로그래밍 언어로 작성된 텍스트 파일
컴파일:소스 파일을 컴퓨터가 이해할 수 있는 기계어로 만드는 과정

객체지향 : 캡슐화, 상속, 다형성 지원

클래스로 캡슐화 : 자바의 모든 변수와 함수는 클래스 내에 선언
                 클래스 안에서 클래스(내부 클래스) 작성 가능
소스(java)와 클래스(class) 파일
하나의 소스 파일에 여러 클래스를 작성 가능
소스 파일의 이름과 public으로 선언된 클래스 이름은 같아야 한다

식별자 : 클래스, 변수, 상수, 메소드 등에 붙는 이름
식별자의 원칙
    특수문자, 공백 또는 탭은 식별자로 사용불가 '_' , '$'는 사용가능
    유니코드 문자 사용 가능, 한글 사용 가능
    자바 언어ㅢ 키워드는 식별자로 사용불가
    식별자의 첫 번쨰 문자로 숫자는 사용불가
    불린 리터럴(true, false)과 널 리터널(null)...

변수 : 프로그램 실행 중에 값을 임시 저장하기 위한 공간

리터럴 : 프로그램에서 직접 표현한 값
        정수, 실수, 문자, 논리, 문자열 리터럴 있음
정수 리터럴 : 10진수, 8진수, 16진수, 2진수 리터럴
             정수 리터럴은 int형으로 컴파일
             long 타입 리터럴은 숫자 뒤에 L 또는 l을 붙여 표시



## 3월 15일
커밋 메세지 안쓰면 커밋이 안됌 꼭 쓸것
