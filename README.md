# 손상협 202330214

## 4월 12일
접근 지정자
    자바의 접근 지정자
        4가지
            private, protected, public, 디폴트
    자바 지정자 목적
        클래스나 이부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
        객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
            접근 지정은 캡슐화에 묶인 보호를 이부 해제할 목적
    접근 지정자에 따른 클래스나 멤버의 공개 법위
클래스 접근 지정
    클래스 접근지정
        가른 클래스에서 사용하도록 허용할 지 지정
        public 클래스
            다른 모든 클래스에게 접근 허용
        디폴트 클래스
            package-private라고도 함
            같은 패키지의 클래스에만 접근 허용
멤버 접근 지정
    public 멤버
        패키지에 관계 없이 모든 클래스에게 접근 허용
    private 멤버
        동일 클래스 내에만 접근 허용
        상속 받은 서브 클래스에서 접근 불가
    protected 멤버
        같은 패키지 내의 다른 모든 클래스에게 접근 허용
        상속 받은 서브 클래스는 다른 패키지에 있어도 접근 가능
static 멤버 선언
    static 멤버 선언
    객체 생성과 non-static 멤버의 생성
        non-static 멤버는 객체가 생성될 때, 객체마다 생긴다
static 멤버의 생성
    static 멤버는 클래스당 하나만 생성
    객체들에 의해 공유됨
static 멤버 사용
    클래스 이름으로 접근 가능
    객체의 멤버로 접근 가능
    non-static 멤버는 클래스 이름으로 접근 안 됨
final 필드
    final 필드, 상수 선언
        상수를 선언할 때 사용
        상수 필드는 선언 시에 초기 값을 지정하여야 한다
        상수 필드는 실행 중에 값을 변경할 수 없다
자바 상속의 특징
    클래스 다중 상속 불허
        C++는 다중 상속 가능
슈퍼 클래스의 대한 서브 클래스의 접근
    슈퍼 클래스의 private 멤버
        서브 클래스에서 접근할 수 없음
    슈퍼 클래스의 디폴트 멤버
        서브 클래스가 동일한 패키지에 있을 때, 접근 가능
다운캐스팅
    다운캐스팅
        슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
        업캐스팅된 것을 다시 원래대로 되돌리는 것
        반드시 명시적 타입 변환 지정
업캐스팅 레퍼런스로 객체 구별
    업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
        슈퍼 클래스는 여러 서브 클래스에 상속되기 때문
instanceof 연산자 사용
    instanceof연산자
        instanceof연산자
            레퍼런스가 가리키는 객체의 타입 식별


## 4월 5일
메소드의 배열 리턴
    배열 리턴
        배열의 레퍼런스만 리턴
    메소드의 리턴 타입
        리턴하는 배열 타입과 리턴 받는 배열 타입 일치
        리턴 타입에 배열의 크기를  지정하지 않음
자바의 예외 처리
    예외 처리
        발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것
        try catch finally문 사용
자바의 객체 지향 특성 : 캡슐화
    캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게  하는 것
        객체의 가장 본질적인 특징
            외부의 접근으로부터 객체 보호
자바의 객체 지향 특성 : 상속
    상위 개체의 속성이 하위 개체에 물려짐
    하위 개체가 상위 개체의 속성을 모두 가지는 관계
자바 상속
    상위 클래스의 멘버를 하위 클래스가 물려받음
        상위 클래스 : 수퍼 클래스
        하위 클래스 : 서브 클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 가능
자바의 객체 지향 특성 : 다형성
    같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
    다향성 사례
        메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
        메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현
객체 지향 언어의 목적
    소프트웨어의 생산성 향상
        컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축
            소프트웨어를 빠른 속도로 생산할 필요성 증대
        객체 지향 언어
            상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
            소프트웨어 재사용과 부분 수정 빠름
            소프트웨어를 다시 만드는 부담 대폭 줄임
            소프트웨어 생산성 향상
    실세계에 대한 쉬운 모델링
        초기 프로그래밍
            수학 계산/통계 처리를 하는 등 처리 과정, 계산 절차 중요
절차 지향 프로그래밍과 객체 지향 프로그래밍
    절차 지향 프로그래밍
        작업 순서를 표현하는 컴퓨터 명령 집합
        함수들의 집합으로 프로그램 작성
클래스와 객체
    클래스
        객체의 속성가 행위 선언
        객체의 설계도 혹은 틀
    객체
        클래스의 틀로 찍어낸 실체
            프로그램 실행 중에 생성되는 실체
            메모리 공간을 갖는 구체적인 실체
            인스턴스 라고도 부름
자바 클래스 구성
    클래스
        class 키워드로 선언
        멤버 클래스 구성 요소
            필드와 메소드
        클래스에 대한 publilc 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락
        멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용
생성자 개념과 목적
    생성자
        객체가 생성될 떄 초기화 목적으로 실행되는 메소드
        객체가 생성되는 순간에 자동 호출
생성자의 특징
    생성자 이름은 클래스 이름과 ㅜ동일
    생성자는 여러 개 작성 가능
    생성자는 객체 생성시 한 번만 호출
        자바에서 객체 생성은 반드시 new 연산로 함
기본 생성자가 자동 생성되지 않는 경우
    클래스에 생성자가 선언되어 있는 경우
        컴파일러는 기본 생성자를 자동 생성해 주지 않는다.
this 레퍼런스
    this
        객체 자신에 대한 레퍼런스
            컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
            this멤버 형태로 멤버를 접근할 떄 사용
객체 배열
    자바의 객체 배열
        객체에 대한 레퍼런스 배열임
    자바의 객체 배열 만들기 3단계
        1.배열 레퍼런스 변수 선언
        2.레퍼런스 배열 생성
        3.배열의 각 원소 객체 생성
메소드
    메소드는 c/c+와 함수와 동일
인자 전달 - 객체가 전달되는 경우
    객체의 레퍼런스만 전달
        매개 변수가 실인자 객체 공유
인자 전달 - 배열이 전달되는 경우
    배열 레퍼런스만 매개 변수에 전달
        배열 통째로 전달되지 않음
    객체가 전달되는 경우와 동일
        매개 변수가 실인자 배열 공유
메소드 오버로딩
    오버로딩
        한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
            메소드 이름이 동일하여야 함
            매개 변수의 개수가 서로 다르거나, 타입이 서로 달라야 함
            리턴 타입은 오버로딩과 관련이 없음
객체 소멸

        new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위
        소멸된 객체 공간은 가용 메모리에 포함
    자바에서 사용자 임의로 객체 소멸안됨
        자바는 객체 소멸 연산자 없음
            객체 생성 연산자 : new
        객체 소멸은 자바 가상 기계의 고유한 역할
        자바 개발자에게는 매우 다행스러운 기능
가비지
    가비지
        가리키는 레퍼런스가 하나도 없는 객체
가비지 컬렉션
    가비지 컬렉션
        자바 가상 기계가 가비지 자동 회수
            가용 메모리 공간이 일정 이하로 부족해질 떄
            가비지를 수거하여 가용 메모리 공간으로 확보
        가비지 컬렉터에 의해 자동 수행
    강제 가비지 컬렉션 강제 수행
자바의 패키지 개념
    패키지
        상호 관련 있는 클래스 파일을 저장하여 관리하는 디렉터리
        자바 응용프로그램은 하나 이상의 패키지로 구성

    

## 3월 29일
기본 타입 이외 리터럴
    null 리터널
        레퍼런스에 대입 사용
상수 선언
    final키워드 사용
    선언 시 초깃값 지정
    실행 중 값 변경 불가
var 키워드
    기존의 변수 선언 방식 : 변수의 타입 반드시 지정
    타입을 생략하고 변수 선언 가능
    컴파일러가 추론하여 변수 타입 결정
    변수 선언 시 초깃갑이 주어지지 않으면 컴파일 오류
    var는 지역 변수 선언에만 한정
타입 변환
    한 타입의 값을 다른 타입의 값으로 변환
강제 타입 변환
    개발자의 의도적 타입 변환
    () 안에 개발자가 명시적으로 타입 변환 지정
    강제 변환은 값 손실 우려
자바의 키 입력과 system.in
    키보드와 연결된 자바의 표준 입력 스트림
    입력되는 키를 바이트로 리턴하는 저수준 스트림
    system.in을 직접 사용하면 바이트를 문자나 숫자로 변환
scanner 클래스
    읽은 바이트를 문자, 정수, 실수, 불린, 문자열 등 다양한 타입으로 변환하여 리턴
    객체 생성
scanner를 이용한 키 입력
    scanner에서 키 입력 받기
    개발자가 원하는 타입 값으로 쉽게 읽을 수 있음
증감 연산
    증가 혹은 감소 시키는 연산
비교 연산, 논리 연산
    비교연산자 : 두 개의 값을 비교하여 true/false 결과
    논리연산자 : 두 개의 값에 논리 연산, 논리 결과
조건 연산
    3 개의 피연산자로 구성된 삼향 연산자


## 3월 22일
ctrl shift p java p create java

소스:프로그래밍 언어로 작성된 텍스트 파일
컴파일:소스 파일을 컴퓨터가 이해할 수 있는 기계어로 만드는 과정

객체지향 : 캡슐화, 상속, 다형성 지원

클래스로 캡슐화 : 자바의 모든 변수와 함수는 클래스 내에 선언
                 클래스 안에서 클래스(내부 클래스) 작성 가능
소스(java)와 클래스(class) 파일
하나의 소스 파일에 여러 클래스를 작성 가능
소스 파일의 이름과 public으로 선언된 클래스 이름은 같아야 한다

식별자 : 클래스, 변수, 상수, 메소드 등에 붙는 이름
식별자의 원칙
    특수문자, 공백 또는 탭은 식별자로 사용불가 '_' , '$'는 사용가능
    유니코드 문자 사용 가능, 한글 사용 가능
    자바 언어ㅢ 키워드는 식별자로 사용불가
    식별자의 첫 번쨰 문자로 숫자는 사용불가
    불린 리터럴(true, false)과 널 리터널(null)...

변수 : 프로그램 실행 중에 값을 임시 저장하기 위한 공간

리터럴 : 프로그램에서 직접 표현한 값
        정수, 실수, 문자, 논리, 문자열 리터럴 있음
정수 리터럴 : 10진수, 8진수, 16진수, 2진수 리터럴
             정수 리터럴은 int형으로 컴파일
             long 타입 리터럴은 숫자 뒤에 L 또는 l을 붙여 표시



## 3월 15일
커밋 메세지 안쓰면 커밋이 안됌 꼭 쓸것
